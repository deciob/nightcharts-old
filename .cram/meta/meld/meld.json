{"absId":"meld/meld","url":"/home/decio/dev/personal/nightcharts-gh/bower_components/meld/meld.js","source":"/** @license MIT License (c) copyright 2011-2013 original author or authors */\n\n/**\n * meld\n * Aspect Oriented Programming for Javascript\n *\n * meld is part of the cujo.js family of libraries (http://cujojs.com/)\n *\n * Licensed under the MIT License at:\n * http://www.opensource.org/licenses/mit-license.php\n *\n * @author Brian Cavalier\n * @author John Hann\n * @version 1.3.0\n */\n(function (define) {\ndefine(function () {\n\n\t//\n\t// Public API\n\t//\n\n\t// Add a single, specific type of advice\n\t// returns a function that will remove the newly-added advice\n\tmeld.before =         adviceApi('before');\n\tmeld.around =         adviceApi('around');\n\tmeld.on =             adviceApi('on');\n\tmeld.afterReturning = adviceApi('afterReturning');\n\tmeld.afterThrowing =  adviceApi('afterThrowing');\n\tmeld.after =          adviceApi('after');\n\n\t// Access to the current joinpoint in advices\n\tmeld.joinpoint =      joinpoint;\n\n\t// DEPRECATED: meld.add(). Use meld() instead\n\t// Returns a function that will remove the newly-added aspect\n\tmeld.add =            function() { return meld.apply(null, arguments); };\n\n\t/**\n\t * Add an aspect to all matching methods of target, or to target itself if\n\t * target is a function and no pointcut is provided.\n\t * @param {object|function} target\n\t * @param {string|array|RegExp|function} [pointcut]\n\t * @param {object} aspect\n\t * @param {function?} aspect.before\n\t * @param {function?} aspect.on\n\t * @param {function?} aspect.around\n\t * @param {function?} aspect.afterReturning\n\t * @param {function?} aspect.afterThrowing\n\t * @param {function?} aspect.after\n\t * @returns {{ remove: function }|function} if target is an object, returns a\n\t *  remover { remove: function } whose remove method will remove the added\n\t *  aspect. If target is a function, returns the newly advised function.\n\t */\n\tfunction meld(target, pointcut, aspect) {\n\t\tvar pointcutType, remove;\n\n\t\tif(arguments.length < 3) {\n\t\t\treturn addAspectToFunction(target, pointcut);\n\t\t} else {\n\t\t\tif (isArray(pointcut)) {\n\t\t\t\tremove = addAspectToAll(target, pointcut, aspect);\n\t\t\t} else {\n\t\t\t\tpointcutType = typeof pointcut;\n\n\t\t\t\tif (pointcutType === 'string') {\n\t\t\t\t\tif (typeof target[pointcut] === 'function') {\n\t\t\t\t\t\tremove = addAspectToMethod(target, pointcut, aspect);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (pointcutType === 'function') {\n\t\t\t\t\tremove = addAspectToAll(target, pointcut(target), aspect);\n\n\t\t\t\t} else {\n\t\t\t\t\tremove = addAspectToMatches(target, pointcut, aspect);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn remove;\n\t\t}\n\n\t}\n\n\tfunction Advisor(target, func) {\n\n\t\tvar orig, advisor, advised;\n\n\t\tthis.target = target;\n\t\tthis.func = func;\n\t\tthis.aspects = {};\n\n\t\torig = this.orig = target[func];\n\t\tadvisor = this;\n\n\t\tadvised = this.advised = function() {\n\t\t\tvar context, joinpoint, args, callOrig, afterType;\n\n\t\t\t// If called as a constructor (i.e. using \"new\"), create a context\n\t\t\t// of the correct type, so that all advice types (including before!)\n\t\t\t// are called with the correct context.\n\t\t\tif(this instanceof advised) {\n\t\t\t\t// shamelessly derived from https://github.com/cujojs/wire/blob/c7c55fe50238ecb4afbb35f902058ab6b32beb8f/lib/component.js#L25\n\t\t\t\tcontext = objectCreate(orig.prototype);\n\t\t\t\tcallOrig = function (args) {\n\t\t\t\t\treturn applyConstructor(orig, context, args);\n\t\t\t\t};\n\n\t\t\t} else {\n\t\t\t\tcontext = this;\n\t\t\t\tcallOrig = function(args) {\n\t\t\t\t\treturn orig.apply(context, args);\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\targs = slice.call(arguments);\n\t\t\tafterType = 'afterReturning';\n\n\t\t\t// Save the previous joinpoint and set the current joinpoint\n\t\t\tjoinpoint = pushJoinpoint({\n\t\t\t\ttarget: context,\n\t\t\t\tmethod: func,\n\t\t\t\targs: args\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tadvisor._callSimpleAdvice('before', context, args);\n\n\t\t\t\ttry {\n\t\t\t\t\tjoinpoint.result = advisor._callAroundAdvice(context, func, args, callOrigAndOn);\n\t\t\t\t} catch(e) {\n\t\t\t\t\tjoinpoint.result = joinpoint.exception = e;\n\t\t\t\t\t// Switch to afterThrowing\n\t\t\t\t\tafterType = 'afterThrowing';\n\t\t\t\t}\n\n\t\t\t\targs = [joinpoint.result];\n\n\t\t\t\tcallAfter(afterType, args);\n\t\t\t\tcallAfter('after', args);\n\n\t\t\t\tif(joinpoint.exception) {\n\t\t\t\t\tthrow joinpoint.exception;\n\t\t\t\t}\n\n\t\t\t\treturn joinpoint.result;\n\n\t\t\t} finally {\n\t\t\t\t// Restore the previous joinpoint, if necessary.\n\t\t\t\tpopJoinpoint();\n\t\t\t}\n\n\t\t\tfunction callOrigAndOn(args) {\n\t\t\t\tvar result = callOrig(args);\n\t\t\t\tadvisor._callSimpleAdvice('on', context, args);\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tfunction callAfter(afterType, args) {\n\t\t\t\tadvisor._callSimpleAdvice(afterType, context, args);\n\t\t\t}\n\t\t};\n\n\t\tdefineProperty(advised, '_advisor', { value: advisor, configurable: true });\n\t}\n\n\tAdvisor.prototype = {\n\n\t\t/**\n\t\t * Invoke all advice functions in the supplied context, with the supplied args\n\t\t *\n\t\t * @param adviceType\n\t\t * @param context\n\t\t * @param args\n\t\t */\n\t\t_callSimpleAdvice: function(adviceType, context, args) {\n\n\t\t\t// before advice runs LIFO, from most-recently added to least-recently added.\n\t\t\t// All other advice is FIFO\n\t\t\tvar iterator, advices;\n\n\t\t\tadvices = this.aspects[adviceType];\n\t\t\tif(!advices) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titerator = iterators[adviceType];\n\n\t\t\titerator(this.aspects[adviceType], function(aspect) {\n\t\t\t\tvar advice = aspect.advice;\n\t\t\t\tadvice && advice.apply(context, args);\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * Invoke all around advice and then the original method\n\t\t *\n\t\t * @param context\n\t\t * @param method\n\t\t * @param args\n\t\t * @param applyOriginal\n\t\t */\n\t\t_callAroundAdvice: function (context, method, args, applyOriginal) {\n\t\t\tvar len, aspects;\n\n\t\t\taspects = this.aspects.around;\n\t\t\tlen = aspects ? aspects.length : 0;\n\n\t\t\t/**\n\t\t\t * Call the next function in the around chain, which will either be another around\n\t\t\t * advice, or the orig method.\n\t\t\t * @param i {Number} index of the around advice\n\t\t\t * @param args {Array} arguments with with to call the next around advice\n\t\t\t */\n\t\t\tfunction callNext(i, args) {\n\t\t\t\t// If we exhausted all aspects, finally call the original\n\t\t\t\t// Otherwise, if we found another around, call it\n\t\t\t\treturn i < 0\n\t\t\t\t\t? applyOriginal(args)\n\t\t\t\t\t: callAround(aspects[i].advice, i, args);\n\t\t\t}\n\n\t\t\tfunction callAround(around, i, args) {\n\t\t\t\tvar proceedCalled, joinpoint;\n\n\t\t\t\tproceedCalled = 0;\n\n\t\t\t\t// Joinpoint is immutable\n\t\t\t\t// TODO: Use Object.freeze once v8 perf problem is fixed\n\t\t\t\tjoinpoint = pushJoinpoint({\n\t\t\t\t\ttarget: context,\n\t\t\t\t\tmethod: method,\n\t\t\t\t\targs: args,\n\t\t\t\t\tproceed: proceedCall,\n\t\t\t\t\tproceedApply: proceedApply,\n\t\t\t\t\tproceedCount: proceedCount\n\t\t\t\t});\n\n\t\t\t\ttry {\n\t\t\t\t\t// Call supplied around advice function\n\t\t\t\t\treturn around.call(context, joinpoint);\n\t\t\t\t} finally {\n\t\t\t\t\tpopJoinpoint();\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * The number of times proceed() has been called\n\t\t\t\t * @return {Number}\n\t\t\t\t */\n\t\t\t\tfunction proceedCount() {\n\t\t\t\t\treturn proceedCalled;\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Proceed to the original method/function or the next around\n\t\t\t\t * advice using original arguments or new argument list if\n\t\t\t\t * arguments.length > 0\n\t\t\t\t * @return {*} result of original method/function or next around advice\n\t\t\t\t */\n\t\t\t\tfunction proceedCall(/* newArg1, newArg2... */) {\n\t\t\t\t\treturn proceed(arguments.length > 0 ? slice.call(arguments) : args);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Proceed to the original method/function or the next around\n\t\t\t\t * advice using original arguments or new argument list if\n\t\t\t\t * newArgs is supplied\n\t\t\t\t * @param [newArgs] {Array} new arguments with which to proceed\n\t\t\t\t * @return {*} result of original method/function or next around advice\n\t\t\t\t */\n\t\t\t\tfunction proceedApply(newArgs) {\n\t\t\t\t\treturn proceed(newArgs || args);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Create proceed function that calls the next around advice, or\n\t\t\t\t * the original.  May be called multiple times, for example, in retry\n\t\t\t\t * scenarios\n\t\t\t\t * @param [args] {Array} optional arguments to use instead of the\n\t\t\t\t * original arguments\n\t\t\t\t */\n\t\t\t\tfunction proceed(args) {\n\t\t\t\t\tproceedCalled++;\n\t\t\t\t\treturn callNext(i - 1, args);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn callNext(len - 1, args);\n\t\t},\n\n\t\t/**\n\t\t * Adds the supplied aspect to the advised target method\n\t\t *\n\t\t * @param aspect\n\t\t */\n\t\tadd: function(aspect) {\n\n\t\t\tvar advisor, aspects;\n\n\t\t\tadvisor = this;\n\t\t\taspects = advisor.aspects;\n\n\t\t\tinsertAspect(aspects, aspect);\n\n\t\t\treturn {\n\t\t\t\tremove: function () {\n\t\t\t\t\tvar remaining = removeAspect(aspects, aspect);\n\n\t\t\t\t\t// If there are no aspects left, restore the original method\n\t\t\t\t\tif (!remaining) {\n\t\t\t\t\t\tadvisor.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Removes the Advisor and thus, all aspects from the advised target method, and\n\t\t * restores the original target method, copying back all properties that may have\n\t\t * been added or updated on the advised function.\n\t\t */\n\t\tremove: function () {\n\t\t\tdelete this.advised._advisor;\n\t\t\tthis.target[this.func] = this.orig;\n\t\t}\n\t};\n\n\t/**\n\t * Returns the advisor for the target object-function pair.  A new advisor\n\t * will be created if one does not already exist.\n\t * @param target {*} target containing a method with tthe supplied methodName\n\t * @param methodName {String} name of method on target for which to get an advisor\n\t * @return {Object|undefined} existing or newly created advisor for the supplied method\n\t */\n\tAdvisor.get = function(target, methodName) {\n\t\tif(!(methodName in target)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar advisor, advised;\n\n\t\tadvised = target[methodName];\n\n\t\tif(typeof advised !== 'function') {\n\t\t\tthrow new Error('Advice can only be applied to functions: ' + methodName);\n\t\t}\n\n\t\tadvisor = advised._advisor;\n\t\tif(!advisor) {\n\t\t\tadvisor = new Advisor(target, methodName);\n\t\t\ttarget[methodName] = advisor.advised;\n\t\t}\n\n\t\treturn advisor;\n\t};\n\n\t/**\n\t * Add an aspect to a pure function, returning an advised version of it.\n\t * NOTE: *only the returned function* is advised.  The original (input) function\n\t * is not modified in any way.\n\t * @param func {Function} function to advise\n\t * @param aspect {Object} aspect to add\n\t * @return {Function} advised function\n\t */\n\tfunction addAspectToFunction(func, aspect) {\n\t\tvar name, placeholderTarget;\n\n\t\tname = func.name || '_';\n\n\t\tplaceholderTarget = {};\n\t\tplaceholderTarget[name] = func;\n\n\t\taddAspectToMethod(placeholderTarget, name, aspect);\n\n\t\treturn placeholderTarget[name];\n\n\t}\n\n\tfunction addAspectToMethod(target, method, aspect) {\n\t\tvar advisor = Advisor.get(target, method);\n\n\t\treturn advisor && advisor.add(aspect);\n\t}\n\n\tfunction addAspectToAll(target, methodArray, aspect) {\n\t\tvar removers, added, f, i;\n\n\t\tremovers = [];\n\t\ti = 0;\n\n\t\twhile((f = methodArray[i++])) {\n\t\t\tadded = addAspectToMethod(target, f, aspect);\n\t\t\tadded && removers.push(added);\n\t\t}\n\n\t\treturn createRemover(removers);\n\t}\n\n\tfunction addAspectToMatches(target, pointcut, aspect) {\n\t\tvar removers = [];\n\t\t// Assume the pointcut is a an object with a .test() method\n\t\tfor (var p in target) {\n\t\t\t// TODO: Decide whether hasOwnProperty is correct here\n\t\t\t// Only apply to own properties that are functions, and match the pointcut regexp\n\t\t\tif (typeof target[p] == 'function' && pointcut.test(p)) {\n\t\t\t\t// if(object.hasOwnProperty(p) && typeof object[p] === 'function' && pointcut.test(p)) {\n\t\t\t\tremovers.push(addAspectToMethod(target, p, aspect));\n\t\t\t}\n\t\t}\n\n\t\treturn createRemover(removers);\n\t}\n\n\tfunction createRemover(removers) {\n\t\treturn {\n\t\t\tremove: function() {\n\t\t\t\tfor (var i = removers.length - 1; i >= 0; --i) {\n\t\t\t\t\tremovers[i].remove();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Create an API function for the specified advice type\n\tfunction adviceApi(type) {\n\t\treturn function(target, method, adviceFunc) {\n\t\t\tvar aspect = {};\n\n\t\t\tif(arguments.length === 2) {\n\t\t\t\taspect[type] = method;\n\t\t\t\treturn meld(target, aspect);\n\t\t\t} else {\n\t\t\t\taspect[type] = adviceFunc;\n\t\t\t\treturn meld(target, method, aspect);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Insert the supplied aspect into aspectList\n\t * @param aspectList {Object} list of aspects, categorized by advice type\n\t * @param aspect {Object} aspect containing one or more supported advice types\n\t */\n\tfunction insertAspect(aspectList, aspect) {\n\t\tvar adviceType, advice, advices;\n\n\t\tfor(adviceType in iterators) {\n\t\t\tadvice = aspect[adviceType];\n\n\t\t\tif(advice) {\n\t\t\t\tadvices = aspectList[adviceType];\n\t\t\t\tif(!advices) {\n\t\t\t\t\taspectList[adviceType] = advices = [];\n\t\t\t\t}\n\n\t\t\t\tadvices.push({\n\t\t\t\t\taspect: aspect,\n\t\t\t\t\tadvice: advice\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Remove the supplied aspect from aspectList\n\t * @param aspectList {Object} list of aspects, categorized by advice type\n\t * @param aspect {Object} aspect containing one or more supported advice types\n\t * @return {Number} Number of *advices* left on the advised function.  If\n\t *  this returns zero, then it is safe to remove the advisor completely.\n\t */\n\tfunction removeAspect(aspectList, aspect) {\n\t\tvar adviceType, advices, remaining;\n\n\t\tremaining = 0;\n\n\t\tfor(adviceType in iterators) {\n\t\t\tadvices = aspectList[adviceType];\n\t\t\tif(advices) {\n\t\t\t\tremaining += advices.length;\n\n\t\t\t\tfor (var i = advices.length - 1; i >= 0; --i) {\n\t\t\t\t\tif (advices[i].aspect === aspect) {\n\t\t\t\t\t\tadvices.splice(i, 1);\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn remaining;\n\t}\n\n\tfunction applyConstructor(C, instance, args) {\n\t\ttry {\n\t\t\t// Try to define a constructor, but don't care if it fails\n\t\t\tdefineProperty(instance, 'constructor', {\n\t\t\t\tvalue: C,\n\t\t\t\tenumerable: false\n\t\t\t});\n\t\t} catch(e) {\n\t\t\t// ignore\n\t\t}\n\n\t\tC.apply(instance, args);\n\n\t\treturn instance;\n\t}\n\n\tvar currentJoinpoint, joinpointStack,\n\t\tap, prepend, append, iterators, slice, isArray, defineProperty, objectCreate;\n\n\t// TOOD: Freeze joinpoints when v8 perf problems are resolved\n//\tfreeze = Object.freeze || function (o) { return o; };\n\n\tjoinpointStack = [];\n\n\tap      = Array.prototype;\n\tprepend = ap.unshift;\n\tappend  = ap.push;\n\tslice   = ap.slice;\n\n\tisArray = Array.isArray || function(it) {\n\t\treturn Object.prototype.toString.call(it) == '[object Array]';\n\t};\n\n\t// Check for a *working* Object.defineProperty, fallback to\n\t// simple assignment.\n\tdefineProperty = definePropertyWorks()\n\t\t? Object.defineProperty\n\t\t: function(obj, prop, descriptor) {\n\t\tobj[prop] = descriptor.value;\n\t};\n\n\tobjectCreate = Object.create ||\n\t\t(function() {\n\t\t\tfunction F() {}\n\t\t\treturn function(proto) {\n\t\t\t\tF.prototype = proto;\n\t\t\t\tvar instance = new F();\n\t\t\t\tF.prototype = null;\n\t\t\t\treturn instance;\n\t\t\t};\n\t\t}());\n\n\titerators = {\n\t\t// Before uses reverse iteration\n\t\tbefore: forEachReverse,\n\t\taround: false\n\t};\n\n\t// All other advice types use forward iteration\n\t// Around is a special case that uses recursion rather than\n\t// iteration.  See Advisor._callAroundAdvice\n\titerators.on\n\t\t= iterators.afterReturning\n\t\t= iterators.afterThrowing\n\t\t= iterators.after\n\t\t= forEach;\n\n\tfunction forEach(array, func) {\n\t\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\t\tfunc(array[i]);\n\t\t}\n\t}\n\n\tfunction forEachReverse(array, func) {\n\t\tfor (var i = array.length - 1; i >= 0; --i) {\n\t\t\tfunc(array[i]);\n\t\t}\n\t}\n\n\tfunction joinpoint() {\n\t\treturn currentJoinpoint;\n\t}\n\n\tfunction pushJoinpoint(newJoinpoint) {\n\t\tjoinpointStack.push(currentJoinpoint);\n\t\treturn currentJoinpoint = newJoinpoint;\n\t}\n\n\tfunction popJoinpoint() {\n\t\treturn currentJoinpoint = joinpointStack.pop();\n\t}\n\n\tfunction definePropertyWorks() {\n\t\ttry {\n\t\t\treturn 'x' in Object.defineProperty({}, 'x', {});\n\t\t} catch (e) { /* return falsey */ }\n\t}\n\n\treturn meld;\n\n});\n})(typeof define == 'function' && define.amd ? define : function (factory) { module.exports = factory(); }\n);\n","modules":[{"pos":401,"count":19,"factory":true,"id":"meld/meld"}],"compileTime":"2014-03-24T21:53:07.413Z"}